<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°ç·šé›»é˜»å¯¦é©—æ¢ç©¶ç³»çµ± | æ•¸æ“šå…±äº«ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', 'Microsoft JhengHei', Arial, sans-serif; }
        body { background-color: #f5f7fa; color: #333; padding: 15px; max-width: 1000px; margin: 0 auto; padding-bottom: 60px; }
        .header { text-align: center; margin-bottom: 20px; padding: 15px 0; background: linear-gradient(135deg, #1e5799 0%, #207cca 51%, #2989d8 100%); color: white; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        h1 { font-size: 1.4em; margin-bottom: 5px; }
        .subtitle { font-size: 0.9em; opacity: 0.9; }
        .card { background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); padding: 15px; margin-bottom: 15px; }
        .card-title { font-weight: bold; margin-bottom: 10px; color: #1e5799; display: flex; align-items: center; }
        .card-title::before { content: "â€¢"; margin-right: 8px; color: #1e5799; font-size: 1.5em; }
        .input-group { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
        .input-row { display: flex; gap: 10px; }
        .input-field { flex: 1; display: flex; flex-direction: column; }
        label { font-size: 0.85em; margin-bottom: 4px; color: #555; }
        input { padding: 10px; border: 1px solid #ddd; border-radius: 5px; font-size: 1em; }
        .button-group { display: flex; gap: 10px; flex-wrap: wrap; }
        button { flex: 1; min-width: 120px; padding: 12px; border: none; border-radius: 5px; background: #1e5799; color: white; font-weight: bold; cursor: pointer; transition: background 0.3s; display: flex; align-items: center; justify-content: center; gap: 8px; }
        button:hover { background: #1a4a85; }
        button.secondary { background: #e0e0e0; color: #333; }
        button.secondary:hover { background: #d0d0d0; }
        button.danger { background: #ff4444; }
        button.danger:hover { background: #e03333; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 10px; text-align: center; border-bottom: 1px solid #eee; }
        th { background-color: #f0f5ff; font-weight: bold; }
        tr.anomaly td { background-color: #ffebee; }
        .chart-container { height: 250px; margin-top: 15px; }
        .prediction-section { background: #f0f7ff; padding: 15px; border-radius: 8px; margin-top: 15px; }
        .prediction-inputs { display: flex; gap: 10px; margin-bottom: 10px; }
        .prediction-results { display: flex; justify-content: space-around; background: white; padding: 10px; border-radius: 5px; font-weight: bold; }
        .note { font-size: 0.8em; color: #666; margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 5px; }
        .footer { text-align: center; margin-top: 20px; font-size: 0.8em; color: #777; padding-top: 15px; border-top: 1px solid #eee; }
        
        /* Modal styles */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; padding: 20px; }
        .modal-content { background-color: white; border-radius: 10px; width: 100%; max-width: 500px; max-height: 90vh; overflow-y: auto; box-shadow: 0 5px 15px rgba(0,0,0,0.2); position: relative; }
        .modal-header { padding: 15px; background: #1e5799; color: white; border-radius: 10px 10px 0 0; display: flex; justify-content: space-between; align-items: center; }
        .close { font-size: 1.5em; cursor: pointer; padding: 0 5px; }
        .modal-body { padding: 20px; }
        
        /* QR åˆ†äº«èˆ‡æƒææ¨£å¼ */
        .qrcode-container { display: flex; justify-content: center; align-items: center; padding: 20px; }
        #qrcode { background: white; padding: 15px; border-radius: 10px; box-shadow: 0 3px 10px rgba(0,0,0,0.1); }
        .qr-segments { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; margin-top: 15px; }
        .qr-segment { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center; }
        .qr-segment-label { font-size: 13px; color: #4b5563; margin-top: 8px; font-weight: 600; }
        
        .camera-container { position: relative; width: 100%; max-width: 400px; margin: 0 auto; border-radius: 8px; overflow: hidden; background: #1f2937; box-shadow: 0 3px 10px rgba(0,0,0,0.2); }
        #video-preview { width: 100%; height: auto; display: block; object-fit: cover; }
        .scan-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; border: 2px solid #42B883; border-radius: 8px; pointer-events: none; box-shadow: 0 0 0 9999px rgba(0,0,0,0.5); }
        .scan-line { position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #2D82B7, #42B883); animation: scanAnimation 2s ease-in-out infinite; }
        @keyframes scanAnimation { 0% { top: 10%; } 50% { top: 90%; } 100% { top: 10%; } }
        
        .progress-container { width: 100%; background-color: #f3f4f6; border-radius: 5px; margin: 15px 0; overflow: hidden; display: none; }
        .progress-bar { height: 10px; background: linear-gradient(90deg, #2D82B7, #42B883); width: 0%; transition: width 0.3s ease; }
        
        .loading { display: none; text-align: center; padding: 15px; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #1e5799; animation: spin 1s linear infinite; margin: 0 auto 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        @media (max-width: 480px) { .input-row { flex-direction: column; } button { min-width: 100%; } .prediction-inputs { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="header">
        <h1>æ¢ç©¶å°ç·šé•·åº¦å°é›»é˜»çš„å½±éŸ¿</h1>
        <div class="subtitle">ç§‘å­¸å¯¦é©—æ¨¡æ“¬ç³»çµ± | è·¨è£ç½®æ•¸æ“šå…±äº«ç‰ˆ</div>
    </div>

    <div class="card">
        <div class="card-title">è¼¸å…¥å¯¦é©—æ•¸æ“š</div>
        <div class="input-group">
            <div class="input-row">
                <div class="input-field">
                    <label for="length">å°ç·šé•·åº¦ (m)</label>
                    <input type="number" id="length" step="0.01" min="0.1" max="10" value="1.00">
                </div>
                <div class="input-field">
                    <label for="current">é›»æµ (A)</label>
                    <input type="number" id="current" step="0.01" min="0.01" max="5" value="0.50">
                </div>
            </div>
            <div class="input-row">
                <div class="input-field">
                    <label for="voltage">é›»å£“ (V)</label>
                    <input type="number" id="voltage" step="0.01" min="0.01" max="20" value="2.50">
                </div>
                <div class="input-field">
                    <label>é›»é˜» (Î©)</label>
                    <input type="text" id="resistance" readonly value="5.00">
                </div>
            </div>
        </div>
        <div class="button-group">
            <button id="add-data"><i>+</i> æ·»åŠ æ•¸æ“šé»</button>
            <button id="clear-data" class="secondary">æ¸…é™¤æ•¸æ“š</button>
            <button id="demo-data" class="secondary">ç¤ºç¯„æ•¸æ“š</button>
        </div>
    </div>

    <div class="card">
        <div class="card-title">å¯¦é©—æ•¸æ“š</div>
        <table id="data-table">
            <thead>
                <tr>
                    <th>å°ç·šé•·åº¦ (m)</th>
                    <th>é›»æµ (A)</th>
                    <th>é›»å£“ (V)</th>
                    <th>é›»é˜» (Î©)</th>
                    <th>æ“ä½œ</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
        
        <div class="chart-container">
            <canvas id="resistance-chart"></canvas>
        </div>
        
        <div class="note" style="margin-top: 10px;">
            å¯¦é©—æ•¸æ“šå›æ­¸ç·š y = <span id="regression-slope">0.00</span>x + <span id="regression-intercept">0.00</span><br>
            æ±ºå®šä¿‚æ•¸ RÂ² = <span id="regression-r2">0.0000</span> ğŸ”®
        </div>
    </div>

    <div class="card">
        <div class="card-title">æ•¸æ“šå…±äº« (æ”¯æ´åˆ†æ®µæƒæ)</div>
        <div class="card" style="margin-top: 15px; background: #e3f2fd;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 1.5em; margin-right: 10px;">ğŸ“¤</span>
                <h3 style="margin: 0; color: #1e5799;">ç™¼é€æ•¸æ“šçµ¦åŒå­¸</h3>
            </div>
            <p style="margin-bottom: 15px; font-size: 0.9em; color: #555;">è‡ªå‹•å£“ç¸®å¤§é‡æ•¸æ“šï¼Œè‹¥æ•¸æ“šè¶…éé™åˆ¶æœƒè‡ªå‹•æ‹†åˆ†ç‚ºå¤šå€‹ QR ç¢¼ã€‚</p>
            <button id="generate-qr" style="width: 100%; background: #1e5799;">ç”Ÿæˆ QR ç¢¼åˆ†äº«</button>
        </div>
        
        <div class="card" style="background: #e8f5e9;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                <span style="font-size: 1.5em; margin-right: 10px;">ğŸ“¥</span>
                <h3 style="margin: 0; color: #388e3c;">æ¥æ”¶åŒå­¸æ•¸æ“š</h3>
            </div>
            <p style="margin-bottom: 15px; font-size: 0.9em; color: #555;">ä½¿ç”¨é¡é ­é€£çºŒæƒæï¼Œç³»çµ±æœƒè‡ªå‹•æ”¶é›†ä¸¦æ‹¼åˆå¤šå¼µ QR ç¢¼çš„æ•¸æ“šã€‚</p>
            <button id="scan-qr" style="width: 100%; background: #388e3c;">æƒæ QR ç¢¼æ¥æ”¶</button>
        </div>
    </div>

    <div class="footer">
        å°ç·šé›»é˜»å¯¦é©—æ¢ç©¶ç³»çµ± | åŸºæ–¼ jsQR è·¨å¹³å°æ•¸æ“šå…±äº«
    </div>

    <div id="share-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>ğŸ“± å¯¦é©—æ•¸æ“š QR ç¢¼</span>
                <span class="close" onclick="closeModals()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="loading" id="qr-loading">
                    <div class="spinner"></div><div>æ­£åœ¨å£“ç¸®ä¸¦ç”Ÿæˆ QR ç¢¼...</div>
                </div>
                <div id="qr-content" style="display: none;">
                    <div id="single-qr-container" style="display:none;">
                        <div class="qrcode-container"><div id="qrcode"></div></div>
                        <div class="note" style="text-align: center;">è«‹å°æ–¹ä½¿ç”¨ç³»çµ±å…§çš„æƒæåŠŸèƒ½è®€å–æ­¤ QR ç¢¼</div>
                    </div>
                    
                    <div id="segmented-qr-container" style="display:none;">
                        <div class="note" style="text-align: center; color: #1e5799; font-weight: bold;">
                            ç”±æ–¼æ•¸æ“šé‡è¼ƒå¤§ï¼Œå·²åˆ†æ‹†ç‚ºå¤šå€‹ QR ç¢¼ã€‚<br>è«‹å°æ–¹é€ä¸€æƒæä»¥ä¸‹æ‰€æœ‰éƒ¨åˆ†ã€‚
                        </div>
                        <div id="qr-segments" class="qr-segments"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="scanner-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>ğŸ“· æƒæ QR ç¢¼æ¥æ”¶æ•¸æ“š</span>
                <span class="close" onclick="closeModals()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="camera-container">
                    <video id="video-preview" autoplay playsinline></video>
                    <div class="scan-overlay"></div>
                    <div class="scan-line"></div>
                    <canvas id="scan-canvas" style="display:none;"></canvas>
                </div>
                
                <div class="progress-container" id="scan-progress">
                    <div class="progress-bar" id="scan-progress-bar"></div>
                </div>
                <div class="note" id="scan-progress-text" style="text-align: center; font-weight: bold; font-size: 1em;">
                    è«‹å°‡ç›¸æ©Ÿå°æº– QR ç¢¼...
                </div>
                
                <div style="text-align: center; margin-top: 15px;">
                    <button id="switch-camera" class="secondary" style="display: inline-flex; min-width: auto; padding: 10px 20px;">åˆ‡æ›å‰å¾Œé¡é ­</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // åŸºæœ¬é‚è¼¯è®Šæ•¸
        let dataPoints = [];
        let chart = null;
        let regression = { slope: 0, intercept: 0, r2: 0 };
        
        // è·¨å¹³å°å…±äº«ç›¸é—œè®Šæ•¸
        const QR_SEGMENT_SIZE = 800; // æ¯å€‹ QR ç¢¼çš„å­—å…ƒä¸Šé™
        let videoStream = null;
        let scanning = false;
        let currentFacingMode = "environment"; // å„ªå…ˆä½¿ç”¨å¾Œç½®é¡é ­
        let receivedSegments = {};
        let totalExpectedSegments = 0;

        // DOM Elements
        const lengthInput = document.getElementById('length');
        const currentInput = document.getElementById('current');
        const voltageInput = document.getElementById('voltage');
        const resistanceInput = document.getElementById('resistance');
        const dataTable = document.getElementById('data-table').getElementsByTagName('tbody')[0];
        const shareModal = document.getElementById('share-modal');
        const scannerModal = document.getElementById('scanner-modal');

        // ================= åŸºæœ¬äº‹ä»¶ç¶å®š =================
        document.addEventListener('DOMContentLoaded', function() {
            [lengthInput, currentInput, voltageInput].forEach(el => el.addEventListener('input', calculateResistance));
            
            document.getElementById('add-data').addEventListener('click', addData);
            document.getElementById('clear-data').addEventListener('click', () => {
                if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ•¸æ“šå—ï¼Ÿ')) { dataPoints = []; updateDataTable(); updateChart(); }
            });
            document.getElementById('demo-data').addEventListener('click', loadDemoData);
            
            // åˆ†äº«èˆ‡æƒææŒ‰éˆ•
            document.getElementById('generate-qr').addEventListener('click', generateQRCode);
            document.getElementById('scan-qr').addEventListener('click', startQRScanner);
            document.getElementById('switch-camera').addEventListener('click', switchCameraDevice);

            calculateResistance();
            initChart();
        });

        // é—œé–‰æ‰€æœ‰ Modal ä¸¦åœæ­¢ç›¸æ©Ÿ
        function closeModals() {
            shareModal.style.display = 'none';
            scannerModal.style.display = 'none';
            scanning = false;
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
        }

        window.onclick = function(event) {
            if (event.target === shareModal || event.target === scannerModal) closeModals();
        }

        // ================= å¯¦é©—æ•¸æ“šé‚è¼¯ =================
        function calculateResistance() {
            const current = parseFloat(currentInput.value) || 0;
            const voltage = parseFloat(voltageInput.value) || 0;
            resistanceInput.value = current > 0 ? (voltage / current).toFixed(2) : '0.00';
        }

        function addData() {
            const length = parseFloat(lengthInput.value);
            const current = parseFloat(currentInput.value);
            const voltage = parseFloat(voltageInput.value);
            if (isNaN(length) || isNaN(current) || isNaN(voltage) || length <= 0 || current <= 0 || voltage <= 0) {
                return alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„æ­£æ•¸å€¼');
            }
            dataPoints.push({ length, current, voltage, resistance: voltage / current });
            updateDataTable(); updateChart();
        }

        function loadDemoData() {
            dataPoints = [0.5, 1.0, 1.5, 2.0, 2.5].map(len => {
                const res = len * 2.0;
                return { length: len, current: 5.0/res, voltage: 5.0, resistance: res };
            });
            updateDataTable(); updateChart();
        }

        function updateDataTable() {
            dataTable.innerHTML = '';
            dataPoints.forEach((point, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${point.length.toFixed(2)}</td>
                    <td>${point.current.toFixed(2)}</td>
                    <td>${point.voltage.toFixed(2)}</td>
                    <td>${point.resistance.toFixed(2)}</td>
                    <td><button class="danger" style="padding: 6px;" onclick="deleteData(${index})">åˆªé™¤</button></td>
                `;
                dataTable.appendChild(row);
            });
        }

        function deleteData(index) {
            dataPoints.splice(index, 1);
            updateDataTable(); updateChart();
        }

        // ================= åœ–è¡¨èˆ‡å›æ­¸åˆ†æ =================
        function initChart() {
            const ctx = document.getElementById('resistance-chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        { label: 'å¯¦é©—æ•¸æ“š', data: [], backgroundColor: '#1e5799', pointRadius: 6 },
                        { label: 'å›æ­¸ç·š', data: [], type: 'line', borderColor: '#ff0000', borderWidth: 2, fill: false, pointRadius: 0 }
                    ]
                },
                options: { responsive: true, maintainAspectRatio: false }
            });
        }

        function updateChart() {
            if (!chart) return;
            const points = dataPoints.map(p => ({ x: p.length, y: p.resistance }));
            if (dataPoints.length >= 2) {
                const result = calculateLinearRegression(dataPoints);
                document.getElementById('regression-slope').textContent = result.slope.toFixed(2);
                document.getElementById('regression-intercept').textContent = result.intercept.toFixed(2);
                document.getElementById('regression-r2').textContent = result.r2.toFixed(4);
                
                if (points.length > 0) {
                    const minX = Math.min(...points.map(p => p.x));
                    const maxX = Math.max(...points.map(p => p.x));
                    chart.data.datasets[1].data = [
                        {x: minX, y: result.slope * minX + result.intercept},
                        {x: maxX, y: result.slope * maxX + result.intercept}
                    ];
                }
            } else {
                chart.data.datasets[1].data = [];
            }
            chart.data.datasets[0].data = points;
            chart.update();
        }

        function calculateLinearRegression(points) {
            const n = points.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            points.forEach(p => {
                sumX += p.length; sumY += p.resistance;
                sumXY += p.length * p.resistance; sumXX += p.length * p.length;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            const meanY = sumY / n;
            let ssTotal = 0, ssResidual = 0;
            points.forEach(p => {
                ssTotal += Math.pow(p.resistance - meanY, 2);
                ssResidual += Math.pow(p.resistance - (slope * p.length + intercept), 2);
            });
            return { slope, intercept, r2: ssTotal === 0 ? 1 : 1 - (ssResidual / ssTotal) };
        }

        // ================= è·¨å¹³å°åˆ†äº« (ç”Ÿæˆå£“ç¸®åˆ†æ®µ QR) =================
        function getCompressedPayload() {
            const payload = {
                experimentType: "wire-resistance",
                timestamp: Date.now(),
                dataPoints: dataPoints
            };
            const jsonString = JSON.stringify(payload);
            
            // ä½¿ç”¨ pako å£“ç¸® (UTF-8 è½‰ Uint8Array å¾Œå£“ç¸®)
            const byteArray = new TextEncoder().encode(jsonString);
            const compressed = pako.deflate(byteArray);
            
            // å°‡ Uint8Array è½‰ç‚º Base64 (é˜²æ­¢ä¸­æ–‡å­—ç¬¦å ±éŒ¯)
            let binary = '';
            for (let i = 0; i < compressed.byteLength; i++) {
                binary += String.fromCharCode(compressed[i]);
            }
            return btoa(binary);
        }

        function generateQRCode() {
            if (dataPoints.length === 0) return alert('è«‹å…ˆæ·»åŠ è‡³å°‘ä¸€çµ„å¯¦é©—æ•¸æ“š');
            
            shareModal.style.display = 'block';
            document.getElementById('qr-loading').style.display = 'block';
            document.getElementById('qr-content').style.display = 'none';

            setTimeout(() => {
                const base64Data = getCompressedPayload();
                const fullData = 'RES_EXP:1:' + base64Data; // è‡ªå®šç¾©å”è­°é ­
                
                const singleCont = document.getElementById('single-qr-container');
                const segCont = document.getElementById('segmented-qr-container');
                
                singleCont.style.display = 'none';
                segCont.style.display = 'none';

                if (fullData.length <= QR_SEGMENT_SIZE) {
                    // æ•¸æ“šå°ï¼Œç”Ÿæˆå–®å€‹ QR ç¢¼
                    singleCont.style.display = 'block';
                    const qrDiv = document.getElementById('qrcode');
                    qrDiv.innerHTML = '';
                    new QRCode(qrDiv, { text: fullData, width: 220, height: 220, correctLevel: QRCode.CorrectLevel.M });
                } else {
                    // æ•¸æ“šéå¤§ï¼Œç”Ÿæˆåˆ†æ®µ QR ç¢¼
                    segCont.style.display = 'block';
                    const segmentsContainer = document.getElementById('qr-segments');
                    segmentsContainer.innerHTML = '';
                    
                    const totalSegments = Math.ceil(fullData.length / QR_SEGMENT_SIZE);
                    for (let i = 0; i < totalSegments; i++) {
                        const chunk = fullData.substring(i * QR_SEGMENT_SIZE, (i + 1) * QR_SEGMENT_SIZE);
                        const segmentData = `${i+1}/${totalSegments}:${chunk}`; // æ ¼å¼: 1/3:å£“ç¸®æ•¸æ“š
                        
                        const wrapper = document.createElement('div');
                        wrapper.className = 'qr-segment';
                        
                        const qrDiv = document.createElement('div');
                        wrapper.appendChild(qrDiv);
                        
                        const label = document.createElement('div');
                        label.className = 'qr-segment-label';
                        label.textContent = `ç¬¬ ${i+1} / ${totalSegments} éƒ¨åˆ†`;
                        wrapper.appendChild(label);
                        
                        segmentsContainer.appendChild(wrapper);
                        new QRCode(qrDiv, { text: segmentData, width: 140, height: 140, correctLevel: QRCode.CorrectLevel.L });
                    }
                }
                
                document.getElementById('qr-loading').style.display = 'none';
                document.getElementById('qr-content').style.display = 'block';
            }, 500);
        }

        // ================= è·¨å¹³å°æ¥æ”¶ (ç›¸æ©Ÿé€£çºŒæƒæ) =================
        async function startQRScanner() {
            scannerModal.style.display = 'block';
            
            // é‡ç½®æ¥æ”¶ç‹€æ…‹
            receivedSegments = {};
            totalExpectedSegments = 0;
            updateScanProgress("è«‹å°‡ç›¸æ©Ÿå°æº– QR ç¢¼...");
            
            await initCamera();
        }

        async function initCamera() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            
            const video = document.getElementById('video-preview');
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: currentFacingMode } 
                });
                video.srcObject = videoStream;
                video.setAttribute("playsinline", true); // iOS Safari å¿…éœ€
                await video.play();
                
                scanning = true;
                requestAnimationFrame(scanLoop);
            } catch (err) {
                console.error("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—:", err);
                alert("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹ç¢ºèªå·²æˆäºˆæ¬Šé™ã€‚\nè©³æƒ…ï¼š" + err.message);
                closeModals();
            }
        }

        function switchCameraDevice() {
            currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
            initCamera();
        }

        function scanLoop() {
            if (!scanning) return;
            
            const video = document.getElementById('video-preview');
            const canvasElement = document.getElementById('scan-canvas');
            const canvas = canvasElement.getContext('2d');
            
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvasElement.height = video.videoHeight;
                canvasElement.width = video.videoWidth;
                canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                
                const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
                // jsQR é€²è¡Œè§£æ
                const code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: "dontInvert" });
                
                if (code) {
                    handleScannedCode(code.data);
                }
            }
            requestAnimationFrame(scanLoop);
        }

        function handleScannedCode(data) {
            // åˆ¤æ–·æ˜¯å¦ç‚ºåˆ†æ®µæ ¼å¼ (ä¾‹ï¼š "1/3:RES_EXP...")
            const segmentMatch = data.match(/^(\d+)\/(\d+):(.*)$/);
            
            if (segmentMatch) {
                const index = parseInt(segmentMatch[1]) - 1;
                const total = parseInt(segmentMatch[2]);
                const chunk = segmentMatch[3];
                
                if (totalExpectedSegments === 0) totalExpectedSegments = total;
                
                if (total === totalExpectedSegments && !receivedSegments[index]) {
                    receivedSegments[index] = chunk;
                    const count = Object.keys(receivedSegments).length;
                    
                    updateScanProgress(`æˆåŠŸè®€å–ç¬¬ ${index + 1} éƒ¨åˆ†ï¼ (é€²åº¦: ${count}/${totalExpectedSegments})`);
                    
                    // æª¢æŸ¥æ˜¯å¦æ‰€æœ‰åˆ†æ®µæ”¶é›†å®Œç•¢
                    if (count === totalExpectedSegments) {
                        scanning = false; // æš«åœæƒæ
                        let fullData = '';
                        for (let i = 0; i < totalExpectedSegments; i++) fullData += receivedSegments[i];
                        
                        setTimeout(() => processReceivedData(fullData), 400); // ç¨å¾®å»¶é²è®“ä½¿ç”¨è€…çœ‹åˆ°æ»¿é€²åº¦
                    }
                }
            } else {
                // å–®å€‹å®Œæ•´ QR ç¢¼
                scanning = false;
                processReceivedData(data);
            }
        }

        function updateScanProgress(text) {
            const progressContainer = document.getElementById('scan-progress');
            const progressBar = document.getElementById('scan-progress-bar');
            const progressText = document.getElementById('scan-progress-text');
            
            if (text) progressText.textContent = text;
            
            if (totalExpectedSegments > 1) {
                progressContainer.style.display = 'block';
                const count = Object.keys(receivedSegments).length;
                progressBar.style.width = `${(count / totalExpectedSegments) * 100}%`;
            } else {
                progressContainer.style.display = 'none';
            }
        }

        function processReceivedData(data) {
            if (!data.startsWith('RES_EXP:1:')) {
                alert('æ•¸æ“šæ ¼å¼éŒ¯èª¤ï¼Œé€™å¯èƒ½ä¸æ˜¯è©²å¯¦é©—ç”¢ç”Ÿçš„ QR ç¢¼ã€‚');
                resetScanState();
                return;
            }

            try {
                // ç§»é™¤å”è­°é ­ä¸¦é€²è¡Œ Base64 è§£ç¢¼
                const base64Data = data.substring('RES_EXP:1:'.length);
                const binary = atob(base64Data);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                
                // Pako è§£å£“ç¸®ä¸¦è½‰å› JSON
                const decompressed = pako.inflate(bytes);
                const jsonString = new TextDecoder().decode(decompressed);
                const payload = JSON.parse(jsonString);
                
                if (payload.experimentType === 'wire-resistance' && payload.dataPoints) {
                    mergeReceivedData(payload.dataPoints);
                    closeModals();
                } else {
                    throw new Error("æ ¼å¼ä¸ç¬¦");
                }
            } catch (e) {
                console.error('æ•¸æ“šè§£æå¤±æ•—:', e);
                alert('æ•¸æ“šè§£æå¤±æ•—ï¼æ•¸æ“šå¯èƒ½å·²ææ¯€æˆ–ç‰ˆæœ¬ä¸ç›¸å®¹ã€‚');
                resetScanState();
            }
        }
        
        function resetScanState() {
            receivedSegments = {};
            totalExpectedSegments = 0;
            updateScanProgress("è«‹å°‡ç›¸æ©Ÿå°æº– QR ç¢¼...");
            scanning = true; // ç¹¼çºŒæƒæ
        }

        function mergeReceivedData(receivedPoints) {
            let newPointsCount = 0;
            
            receivedPoints.forEach(newPoint => {
                // æª¢æŸ¥é‡è¤‡æ•¸æ“š
                const exists = dataPoints.some(point => 
                    Math.abs(point.length - newPoint.length) < 0.01 &&
                    Math.abs(point.voltage - newPoint.voltage) < 0.01 &&
                    Math.abs(point.current - newPoint.current) < 0.01
                );
                
                if (!exists) {
                    dataPoints.push(newPoint);
                    newPointsCount++;
                }
            });
            
            updateDataTable();
            updateChart();
            
            if (newPointsCount > 0) {
                alert(`æˆåŠŸè®€å–ä¸¦åˆä½µäº† ${newPointsCount} çµ„æ–°å¯¦é©—æ•¸æ“šé»ï¼`);
            } else {
                alert('æƒææˆåŠŸï¼Œä½†æ‰€æœ‰æ¥æ”¶çš„æ•¸æ“šé»å‡å·²å­˜åœ¨æ–¼æ‚¨çš„åˆ—è¡¨ä¸­ã€‚');
            }
        }
    </script>
</body>
</html>